<script type="text/javascript">
	// 全局变量：当前选中的角色
	let currentSelectedAgent = null;
	let start_datetime_temp = null; // 临时存储，等待Flask数据加载

	// 格式化时间戳函数（用于匹配日志格式）
	function formatTimestamp(date) {
		if (!date) return '';
		let year = date.getFullYear();
		let month = String(date.getMonth() + 1).padStart(2, '0');
		let day = String(date.getDate()).padStart(2, '0');
		let hour = String(date.getHours()).padStart(2, '0');
		let minute = String(date.getMinutes()).padStart(2, '0');
		return `${year}${month}${day}-${hour}:${minute}`;
	}

	// 格式化并显示角色日志
	function updateRightContainerLogs(agentName, agentLogsData, currentTime) {
		if (!agentLogsData || !agentLogsData[agentName] || !agentLogsData[agentName].timeline) {
			rightContainer.innerHTML = '<div style="line-height:1.8;padding:10px;">未找到该角色的日志数据。</div>';
			return;
		}

		let timeline = agentLogsData[agentName].timeline;
		let currentTimestamp = formatTimestamp(currentTime);
		
		let logsText = `<div style="line-height:1.8;">`;
		logsText += `<h3 style="margin-top:0;">=== ${agentName} 的日志 ===</h3>`;
		logsText += `<p><strong>当前时间:</strong> ${currentTimestamp}</p>`;
		logsText += `<p><strong>开始时间:</strong> ${timeline[0] ? timeline[0].timestamp : "未知"}</p>`;
		logsText += `<hr style="border:1px solid #eee;margin:15px 0;">`;
		
		// 过滤并显示当前时间之前的日志
		for (let i = 0; i < timeline.length; i++) {
			let log = timeline[i];
			if (log.timestamp <= currentTimestamp) {
				logsText += `<div style="margin-bottom:20px;">`;
				logsText += `<p><strong>[${log.timestamp}] Step ${log.step}</strong></p>`;
				logsText += `<p>位置: ${log.location || "未知"}</p>`;
				logsText += `<p>活动: ${log.action_describe || "无"}</p>`;
				logsText += `<p>状态: ${log.currently || "无"}</p>`;
				if (log.chats_count > 0) {
					logsText += `<p>对话数: ${log.chats_count}</p>`;
				}
				logsText += `</div>`;
				logsText += `<hr style="border:1px solid #eee;margin:15px 0;">`;
			}
		}
		logsText += `</div>`;
		
		rightContainer.innerHTML = logsText;
	}

	// 创建左侧【人物日志】按钮
	const btnLog = document.createElement('button');
	btnLog.textContent = '【人物日志】';
	btnLog.style.cssText = 'position:fixed;left:20px;top:20px;padding:10px 20px;font-size:16px;cursor:pointer;z-index:1001;';
	document.body.appendChild(btnLog);

	// 创建右侧白色容器
	const rightContainer = document.createElement('div');
	rightContainer.style.cssText = 'position:fixed;right:16px;top:16px;width:calc(50% - 24px);height:calc(50vh - 32px);margin-left:8px;background:#fff;border:1px solid #ddd;border-radius:8px;overflow-y:auto;overflow-x:hidden;padding:16px;box-sizing:border-box;color:#000;z-index:1000;';
	document.body.appendChild(rightContainer);

	// 创建左侧浮层遮罩
	const overlay = document.createElement('div');
	overlay.style.cssText = 'position:fixed;left:0;top:0;width:40%;height:100%;background:rgba(0,0,0,0.5);z-index:1002;display:none;';
	document.body.appendChild(overlay);

	// 创建人物列表容器
	const listContainer = document.createElement('div');
	listContainer.style.cssText = 'position:fixed;left:0;top:0;width:40%;height:100%;background:#fff;z-index:1003;padding:20px;box-sizing:border-box;transform:translateX(-100%);transition:transform 0.3s;';
	document.body.appendChild(listContainer);

	// 按钮点击事件：显示浮层
	btnLog.onclick = () => {
		// 清空列表并重新生成
		listContainer.innerHTML = '';
		
		// 从agent_logs_data中获取可用角色列表
		let agents = [];
		if (typeof agent_logs_data !== 'undefined' && agent_logs_data) {
			for (let name in agent_logs_data) {
				if (agent_logs_data[name] && agent_logs_data[name].timeline) {
					agents.push(name);
				}
			}
		}
		
		// 如果没有可用角色，显示提示
		if (agents.length === 0) {
			const emptyMsg = document.createElement('div');
			emptyMsg.textContent = '暂无可用的日志数据';
			emptyMsg.style.cssText = 'padding:15px;color:#999;';
			listContainer.appendChild(emptyMsg);
		} else {
			// 创建人物列表项
			agents.forEach(name => {
				const item = document.createElement('div');
				item.textContent = name;
				item.style.cssText = 'padding:15px;border-bottom:1px solid #eee;cursor:pointer;transition:background 0.2s;';
				item.onmouseenter = () => item.style.background = '#f5f5f5';
				item.onmouseleave = () => item.style.background = '#fff';
				item.onclick = () => {
					// 浮层收回
					listContainer.style.transform = 'translateX(-100%)';
					overlay.style.display = 'none';
					// 设置当前选中角色
					currentSelectedAgent = name;
					// 更新右侧容器内容（使用当前时间，如果start_datetime已初始化则使用它，否则使用当前时间）
					let currentTime = (typeof start_datetime !== 'undefined' && start_datetime) ? start_datetime : (start_datetime_temp || new Date());
					updateRightContainerLogs(name, agent_logs_data, currentTime);
					// 容器回到顶部
					rightContainer.scrollTop = 0;
				};
				listContainer.appendChild(item);
			});
		}
		
		overlay.style.display = 'block';
		listContainer.style.transform = 'translateX(0)';
	};

	// 遮罩点击事件：关闭浮层
	overlay.onclick = () => {
		listContainer.style.transform = 'translateX(-100%)';
		overlay.style.display = 'none';
	};

	// Initialize variables from Flask context
	let step = {{ step|tojson }};
	let step_size = {{ sec_per_step|tojson }} * 1000; // Convert to milliseconds
	let zoom = {{ zoom|tojson }};
	if (zoom <= 0) zoom = document.documentElement.clientWidth / 4400;

	let tile_width = 32;
	let movement_speed = {{ play_speed|tojson }};
	let execute_count_max = tile_width / movement_speed;
	let execute_count = execute_count_max;
	let all_movement = {{ all_movement|tojson }};

	let datetime_options = { weekday: "long", year: "numeric", month: "long", day: "numeric" };
	let start_datetime = new Date(Date.parse({{ start_datetime|tojson }}));
	// 保存初始时间供右侧容器使用
	start_datetime_temp = start_datetime;

	// Agent logs data
	let agent_logs_data = {{ agent_logs|tojson }} || {};
	let show_agent_logs = false;
	let selected_agent = null;

	// Persona related variables
	let persona_names = {{ persona_init_pos|tojson }};
	var spawn_tile_loc = {};
	for (var key in persona_names) {
		spawn_tile_loc[key] = persona_names[key];
	}

	var personas = {};
	var pronunciatios = {};
	let anims_direction;
	let pre_anims_direction;
	let pre_anims_direction_dict = {};

	let movement_target = {};

	let finished = false;
	let paused = false;

	// Function to update agent list display
	function updateAgentList() {
		if (!show_agent_logs || selected_agent !== null) return;
		
		let listText = "请选择要查看日志的角色：\n\n";
		let agentCount = 0;
		for (let agentName in agent_logs_data) {
			if (agent_logs_data[agentName] && agent_logs_data[agentName].timeline) {
				listText += `[${agentName}] - 点击查看日志\n`;
				agentCount++;
			}
		}
		
		if (agentCount === 0) {
			listText += "暂无可用的日志数据。\n";
		}
		
		textAgentList.updateText(listText);
	}

	// Function to format datetime to match log format (YYYYMMDD-HH:MM)
	function formatTimestamp(date) {
		let year = date.getFullYear();
		let month = String(date.getMonth() + 1).padStart(2, '0');
		let day = String(date.getDate()).padStart(2, '0');
		let hour = String(date.getHours()).padStart(2, '0');
		let minute = String(date.getMinutes()).padStart(2, '0');
		return `${year}${month}${day}-${hour}:${minute}`;
	}

	// Function to update agent logs display
	function updateAgentLogs(agentName) {
		if (!agent_logs_data[agentName] || !agent_logs_data[agentName].timeline) {
			textAgentLogs.updateText("未找到该角色的日志数据。");
			return;
		}

		let timeline = agent_logs_data[agentName].timeline;
		let currentTimestamp = formatTimestamp(start_datetime);
		
		let logsText = `=== ${agentName} 的日志 ===\n\n`;
		logsText += `[返回] - 点击返回角色列表\n\n`;
		logsText += `当前时间: ${currentTimestamp}\n`;
		logsText += `开始时间: ${timeline[0] ? timeline[0].timestamp : "未知"}\n\n`;
		logsText += "─────────────────────────────\n\n";
		
		// Filter logs up to current time
		for (let i = 0; i < timeline.length; i++) {
			let log = timeline[i];
			if (log.timestamp <= currentTimestamp) {
				logsText += `[${log.timestamp}] Step ${log.step}\n`;
				logsText += `位置: ${log.location || "未知"}\n`;
				logsText += `活动: ${log.action_describe || "无"}\n`;
				logsText += `状态: ${log.currently || "无"}\n`;
				if (log.chats_count > 0) {
					logsText += `对话数: ${log.chats_count}\n`;
				}
				logsText += "\n─────────────────────────────\n\n";
			}
		}
		
		textAgentLogs.updateText(logsText);
	}

	// Phaser configuration
	const config = {
		type: Phaser.AUTO,
		// width: 4480,
		// height: 3200,
        width: document.documentElement.clientWidth / zoom,
        height: document.documentElement.clientHeight / zoom,
		parent: "game-container",
        mode: Phaser.Scale.FIT,
		pixelArt: true,
		physics: {
			default: "arcade",
			arcade: {
				gravity: { y: 0 }
			}
		},
		scene: {
			preload: preload,
			create: create,
			update: update
		},
		scale: {
			zoom: zoom
		}
	};

	// Create Phaser game instance
	const game = new Phaser.Game(config);
	let cursors;
	let player;

	// Preload function
	function preload() {
		this.load.crossOrigin = "";

		// Load images
		this.load.image("blocks_1", "static/assets/village/tilemap/blocks_1.png");
		this.load.image("walls", "static/assets/village/tilemap/Room_Builder_32x32.png");
		this.load.image("interiors_pt1", "static/assets/village/tilemap/interiors_pt1.png");
		this.load.image("interiors_pt2", "static/assets/village/tilemap/interiors_pt2.png");
		this.load.image("interiors_pt3", "static/assets/village/tilemap/interiors_pt3.png");
		this.load.image("interiors_pt4", "static/assets/village/tilemap/interiors_pt4.png");
		this.load.image("interiors_pt5", "static/assets/village/tilemap/interiors_pt5.png");
		this.load.image("CuteRPG_Field_B", "static/assets/village/tilemap/CuteRPG_Field_B.png");
		this.load.image("CuteRPG_Field_C", "static/assets/village/tilemap/CuteRPG_Field_C.png");
		this.load.image("CuteRPG_Harbor_C", "static/assets/village/tilemap/CuteRPG_Harbor_C.png");
		this.load.image("CuteRPG_Village_B", "static/assets/village/tilemap/CuteRPG_Village_B.png");
		this.load.image("CuteRPG_Forest_B", "static/assets/village/tilemap/CuteRPG_Forest_B.png");
		this.load.image("CuteRPG_Desert_C", "static/assets/village/tilemap/CuteRPG_Desert_C.png");
		this.load.image("CuteRPG_Mountains_B", "static/assets/village/tilemap/CuteRPG_Mountains_B.png");
		this.load.image("CuteRPG_Desert_B", "static/assets/village/tilemap/CuteRPG_Desert_B.png");
		this.load.image("CuteRPG_Forest_C", "static/assets/village/tilemap/CuteRPG_Forest_C.png");

		// Load tilemap JSON
		this.load.tilemapTiledJSON("map", "static/assets/village/tilemap/tilemap.json");

		this.load.atlas("atlas", "static/assets/village/agents/苏沐晴/texture.png", filename="static/assets/village/agents/sprite.json");

		// Load persona atlases
		for (var p in persona_names) {
			image_static = "static/assets/village/agents/" + p + "/texture.png";
			this.load.atlas(p, image_static, filename="static/assets/village/agents/sprite.json");
		}
	}

	// Create function
	function create() {
		const map = this.make.tilemap({ key: "map" });

		// Add tilesets and layers
		const collisions = map.addTilesetImage("blocks", "blocks_1");
		const walls = map.addTilesetImage("Room_Builder_32x32", "walls");
		const interiors_pt1 = map.addTilesetImage("interiors_pt1", "interiors_pt1");
		const interiors_pt2 = map.addTilesetImage("interiors_pt2", "interiors_pt2");
		const interiors_pt3 = map.addTilesetImage("interiors_pt3", "interiors_pt3");
		const interiors_pt4 = map.addTilesetImage("interiors_pt4", "interiors_pt4");
		const interiors_pt5 = map.addTilesetImage("interiors_pt5", "interiors_pt5");
		const CuteRPG_Field_B = map.addTilesetImage("CuteRPG_Field_B", "CuteRPG_Field_B");
		const CuteRPG_Field_C = map.addTilesetImage("CuteRPG_Field_C", "CuteRPG_Field_C");
		const CuteRPG_Harbor_C = map.addTilesetImage("CuteRPG_Harbor_C", "CuteRPG_Harbor_C");
		const CuteRPG_Village_B = map.addTilesetImage("CuteRPG_Village_B", "CuteRPG_Village_B");
		const CuteRPG_Forest_B = map.addTilesetImage("CuteRPG_Forest_B", "CuteRPG_Forest_B");
		const CuteRPG_Desert_C = map.addTilesetImage("CuteRPG_Desert_C", "CuteRPG_Desert_C");
		const CuteRPG_Mountains_B = map.addTilesetImage("CuteRPG_Mountains_B", "CuteRPG_Mountains_B");
		const CuteRPG_Desert_B = map.addTilesetImage("CuteRPG_Desert_B", "CuteRPG_Desert_B");
		const CuteRPG_Forest_C = map.addTilesetImage("CuteRPG_Forest_C", "CuteRPG_Forest_C");

		let tileset_group_1 = [CuteRPG_Field_B, CuteRPG_Field_C, CuteRPG_Harbor_C, CuteRPG_Village_B,
			CuteRPG_Forest_B, CuteRPG_Desert_C, CuteRPG_Mountains_B, CuteRPG_Desert_B, CuteRPG_Forest_C,
			interiors_pt1, interiors_pt2, interiors_pt3, interiors_pt4, interiors_pt5, walls];
		const bottomGroundLayer = map.createLayer("Bottom Ground", tileset_group_1, 0, 0);
		const exteriorGroundLayer = map.createLayer("Exterior Ground", tileset_group_1, 0, 0);
		const exteriorDecorationL1Layer = map.createLayer("Exterior Decoration L1", tileset_group_1, 0, 0);
		const exteriorDecorationL2Layer = map.createLayer("Exterior Decoration L2", tileset_group_1, 0, 0);
		const interiorGroundLayer = map.createLayer("Interior Ground", tileset_group_1, 0, 0);
		const wallLayer = map.createLayer("Wall", [CuteRPG_Field_C, walls], 0, 0);
		const interiorFurnitureL1Layer = map.createLayer("Interior Furniture L1", tileset_group_1, 0, 0);
		const interiorFurnitureL2Layer = map.createLayer("Interior Furniture L2 ", tileset_group_1, 0, 0);
		const foregroundL1Layer = map.createLayer("Foreground L1", tileset_group_1, 0, 0);
		const foregroundL2Layer = map.createLayer("Foreground L2", tileset_group_1, 0, 0);

		const collisionsLayer = map.createLayer("Collisions", collisions, 0, 0);

		collisionsLayer.setCollisionByProperty({ collide: true });

		collisionsLayer.setDepth(-1);
		foregroundL1Layer.setDepth(2);
		foregroundL2Layer.setDepth(2);

		const canvas = game.canvas;
		canvas.addEventListener("wheel", (event) => {
			event.stopPropagation();
		}, { passive: false, capture: true });

		function add_text(game, x, y, text, background) {
			res = game.add.text(
				x,
				y,
				text,
				{
					font: "24px 黑体",
					fontWeight: "normal",
					fill: "#000000",
					backgroundColor: background,
					padding: { x: 20, y: 4},
					align: "left",
					wordWrap: { width: 1200/zoom, useAdvancedWrap: true },
				}
			);

			res.setDepth(10);
			res.alpha = 0.8;
			res.setScrollFactor(0);

			return res;
		}

		function add_scrollable_text(game, x, y, text, background, maxHeight, boxWidth) {
			maxHeight = maxHeight || 400;
			boxWidth = boxWidth || 1200/zoom;
			
			// Create a container for scrollable text
			let container = game.add.container(x, y);
			container.setDepth(11);
			container.setScrollFactor(0);
			
			// Create background rectangle with more visible styling
			let bg = game.add.rectangle(0, 0, boxWidth, maxHeight, 0xffffff, 0.95);
			bg.setStrokeStyle(3, 0x333333); // Thicker, darker border
			bg.setOrigin(0, 0);
			container.add(bg);
			
			// Create text object with proper positioning
			let textObj = game.add.text(
				20,
				20,
				text,
				{
					font: "18px 黑体",
					fontWeight: "normal",
					fill: "#000000",
					align: "left",
					wordWrap: { width: boxWidth - 40, useAdvancedWrap: true },
				}
			);
			textObj.setOrigin(0, 0);
			container.add(textObj);
			
			// Add scroll functionality
			let scrollY = 0;
			let updateMaxScroll = function() {
				let textHeight = textObj.height;
				return Math.max(0, textHeight - maxHeight + 40);
			};
			let maxScroll = updateMaxScroll();
			
			// Make container interactive for scrolling
			container.setInteractive(new Phaser.Geom.Rectangle(0, 0, boxWidth, maxHeight), Phaser.Geom.Rectangle.Contains);
			container.on('wheel', function(pointer, gameObjects, deltaX, deltaY, deltaZ) {
				if (container.visible) {
					scrollY += deltaY * 0.5;
					maxScroll = updateMaxScroll();
					scrollY = Phaser.Math.Clamp(scrollY, -maxScroll, 0);
					textObj.y = 20 + scrollY;
				}
			});
			
			// Store references and update function
			container.textObj = textObj;
			container.bg = bg;
			container.maxHeight = maxHeight;
			container.boxWidth = boxWidth;
			container.updateText = function(newText) {
				this.textObj.setText(newText);
				maxScroll = updateMaxScroll();
				scrollY = Phaser.Math.Clamp(scrollY, -maxScroll, 0);
				this.textObj.y = 20 + scrollY;
			};
			
			return container;
		}

		posX = 20;
		posY = 20;

		// Add button: play, pause ...
		buttonPlay = add_text(this, posX, posY, "[运行]", "#ffffcc");
		buttonPlay.setInteractive();
		posX += buttonPlay.width + 10;

		buttonPause = add_text(this, posX, posY, " 暂停 ", "#ffffcc");
		buttonPause.setInteractive();
		posX += buttonPause.width + 10;

		buttonShowConversation = add_text(this, posX, posY, "[显示对话]", "#ffffcc");
		buttonShowConversation.setInteractive();
		posX += buttonShowConversation.width + 10;

		buttonHideConversation = add_text(this, posX, posY, " 隐藏对话 ", "#ffffcc");
		buttonHideConversation.setInteractive();
		posX += buttonHideConversation.width + 10;

		buttonShowAgentLogs = add_text(this, posX, posY, "[人物日志]", "#ffffcc");
		buttonShowAgentLogs.setInteractive();
		posX += buttonShowAgentLogs.width + 10;

		buttonHideAgentLogs = add_text(this, posX, posY, " 隐藏日志 ", "#ffffcc");
		buttonHideAgentLogs.setInteractive();
		posX += buttonHideAgentLogs.width + 10;

		// Show current time
		currentTime = add_text(this, posX, posY, "", "#ccffcc");

		// Show conversation content
		textConversation = add_text(this, 20, posY + currentTime.height + 10, " —— ", "#ccffcc");

		// Calculate position for agent logs (to the right of conversation box)
		let conversationBoxWidth = 1200/zoom;
		let spacing = 20;
		let logsBoxX = 20 + conversationBoxWidth + spacing;
		
		// Calculate available width for logs box
		let screenWidth = document.documentElement.clientWidth / zoom;
		let logsBoxWidth = Math.min(1200/zoom, screenWidth - logsBoxX - 20);
		
		// Show agent list (for selecting agent to view logs) - use scrollable text with background
		// 创建代理列表容器
		textAgentList = add_scrollable_text(this, logsBoxX, posY + currentTime.height + 10, " —— ", "#ccffff", 500, logsBoxWidth);
		textAgentList.setVisible(false);

		// Show agent logs content (scrollable) - positioned to the right of conversation
		// 创建代理日志容器
		textAgentLogs = add_scrollable_text(this, logsBoxX, posY + currentTime.height + 10, " —— ", "#ffffcc", 500, logsBoxWidth);
		textAgentLogs.setVisible(false);

		// Handle agent selection - make agent names clickable
		textAgentList.setInteractive(new Phaser.Geom.Rectangle(0, 0, logsBoxWidth, 500), Phaser.Geom.Rectangle.Contains);
		textAgentList.on("pointerdown", function(pointer) {
			if (selected_agent !== null) return;
			
			// Get click position relative to textAgentList container
			let localX = pointer.x - textAgentList.x;
			let localY = pointer.y - textAgentList.y;
			
			// Only process clicks within the container bounds
			if (localX >= 0 && localX <= logsBoxWidth && localY >= 0 && localY <= 500) {
				let agentNames = Object.keys(agent_logs_data || {}).filter(name => 
					agent_logs_data[name] && agent_logs_data[name].timeline
				);
				
				// Calculate which agent was clicked based on text position
				// Each agent entry is roughly 40 pixels tall, starting from position 20
				if (localY > 20 && localY < 20 + agentNames.length * 40) {
					let agentIndex = Math.floor((localY - 20) / 40);
					
					if (agentIndex >= 0 && agentIndex < agentNames.length) {
						selected_agent = agentNames[agentIndex];
						textAgentList.setVisible(false);
						textAgentLogs.setVisible(true);
						updateAgentLogs(selected_agent);
					}
				}
			}
		});

		// Handle back button in logs view
		textAgentLogs.setInteractive(new Phaser.Geom.Rectangle(0, 0, logsBoxWidth, 500), Phaser.Geom.Rectangle.Contains);
		textAgentLogs.on("pointerdown", function(pointer) {
			if (selected_agent === null) return;
			
			let localX = pointer.x - textAgentLogs.x;
			let localY = pointer.y - textAgentLogs.y;
			
			// Only process clicks within the container bounds
			if (localX >= 0 && localX <= logsBoxWidth && localY >= 0 && localY <= 500) {
				// Check if clicked on "[返回]" area (roughly first 60 pixels from top)
				if (localY > 0 && localY < 60) {
					selected_agent = null;
					textAgentList.setVisible(true);
					textAgentLogs.setVisible(false);
					updateAgentList();
				}
			}
		});

		// Setup camera
		player = this.physics.add.sprite(2440, 500, "atlas", "down").setSize(30, 40).setOffset(0, 0);
		player.setDepth(-1);
		const camera = this.cameras.main;
		camera.startFollow(player);
		camera.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
		cursors = this.input.keyboard.createCursorKeys();

		// Setup personas
		// We start by creating the game sprite objects.
		for (let i=0; i<Object.keys(spawn_tile_loc).length; i++) {
			let persona_name = Object.keys(spawn_tile_loc)[i];
			let start_pos = [spawn_tile_loc[persona_name][0] * tile_width + tile_width / 2, spawn_tile_loc[persona_name][1] * tile_width + tile_width];
			let new_sprite = this.physics.add.sprite(start_pos[0], start_pos[1], persona_name, "down").setSize(30, 40).setOffset(0, 0);
			// Scale up the sprite
			new_sprite.displayWidth = 40;
			new_sprite.scaleY = new_sprite.scaleX;

			// Here, we are creating the persona and its pronunciatio sprites.
			personas[persona_name] = new_sprite;
			pronunciatios[persona_name] = this.add.text(
				new_sprite.body.x - 15,
				new_sprite.body.y - 15 - 25,
				"",
				{
					font: "18px monospace",
					fill: "#000000",
					backgroundColor: "#ffffcc",
					padding: { x: 4, y: 4},
					border:"solid",
					borderRadius:"10px"
				}
			).setDepth(3);
			pronunciatios[persona_name].alpha = 0.7;
		}

		// Create animations
		const anims = this.anims;
		for (let i = 0; i < Object.keys(persona_names).length; i++) {
			let persona_name = Object.keys(persona_names)[i];
			let left_walk_name = persona_name + "-left-walk";
			let right_walk_name = persona_name + "-right-walk";
			let down_walk_name = persona_name + "-down-walk";
			let up_walk_name = persona_name + "-up-walk";

			frameRate = 4;
			if (movement_speed > 1) frameRate = 8;

			anims.create({
				key: left_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "left-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: right_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "right-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: down_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "down-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: up_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "up-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});
		}
	}

	// Update function
	function update(time, delta) {
		// Setup play and pause button
		buttonPlay.on("pointerdown", function() {
			if (finished) return;
			buttonPlay.text = "[运行]";
			buttonPause.text = " 暂停 ";
			paused = false;
		});

		buttonPause.on("pointerdown", function() {
			if (finished) return;
			buttonPlay.text = " 运行 ";
			buttonPause.text = "[暂停]";
			paused = true;
		});

		buttonShowConversation.on("pointerdown", function() {
			buttonShowConversation.text = "[显示对话]";
			buttonHideConversation.text = " 隐藏对话 ";
			textConversation.setVisible(true);
		});

		buttonHideConversation.on("pointerdown", function() {
			buttonShowConversation.text = " 显示对话 ";
			buttonHideConversation.text = "[隐藏对话]";
			textConversation.setVisible(false);
		});

		buttonShowAgentLogs.on("pointerdown", function() {
			buttonShowAgentLogs.text = "[人物日志]";
			buttonHideAgentLogs.text = " 隐藏日志 ";
			show_agent_logs = true;
			selected_agent = null;
			updateAgentList();
			textAgentList.setVisible(true);
			textAgentLogs.setVisible(false);
		});

		buttonHideAgentLogs.on("pointerdown", function() {
			buttonShowAgentLogs.text = " 人物日志 ";
			buttonHideAgentLogs.text = "[隐藏日志]";
			show_agent_logs = false;
			selected_agent = null;
			textAgentList.setVisible(false);
			textAgentLogs.setVisible(false);
		});

		// Move camera
		const camera_speed = 400;
		player.body.setVelocity(0);
		if (cursors.left.isDown) {
			player.body.setVelocityX(-camera_speed);
		}
		if (cursors.right.isDown) {
			player.body.setVelocityX(camera_speed);
		}
		if (cursors.up.isDown) {
			player.body.setVelocityY(-camera_speed);
		}
		if (cursors.down.isDown) {
			player.body.setVelocityY(camera_speed);
		}

		let curr_focused_persona = document.getElementById("temp_focus").textContent;
		if (curr_focused_persona != "") {
			player.body.x = personas[curr_focused_persona].body.x;
			player.body.y = personas[curr_focused_persona].body.y;
			document.getElementById("temp_focus").innerHTML = "";
		}

		if (finished || paused) {
			return;
		}

		curr_datetime = new Date(start_datetime.getTime());
		curr_year = curr_datetime.getFullYear().toString().padStart(4, "0");
		curr_month = (curr_datetime.getMonth() + 1).toString().padStart(2, "0");
		curr_day = curr_datetime.getDate().toString().padStart(2, "0");
		curr_hour = curr_datetime.getHours().toString().padStart(2, "0");
		curr_minute = curr_datetime.getMinutes().toString().padStart(2, "0");
		conversation_key = `${curr_year}${curr_month}${curr_day}-${curr_hour}:${curr_minute}`;
		conversation_key_text = all_movement["conversation"][conversation_key];
		if (conversation_key_text && conversation_key_text != "") {
			textConversation.setText(`\n${conversation_key} 对话记录：\n` + conversation_key_text);
		}

		// Moving personas
		for (let i = 0; i < Object.keys(personas).length; i++) {
			let curr_persona_name = Object.keys(personas)[i];
			let curr_persona = personas[curr_persona_name];
			let curr_pronunciatio = pronunciatios[Object.keys(personas)[i]];

			if (step in all_movement) {
				if (curr_persona_name.replace("_", " ") in all_movement[step]) {
					if (execute_count == execute_count_max) {
						let curr_x = all_movement[step][curr_persona_name.replace("_", " ")]["movement"][0];
						let curr_y = all_movement[step][curr_persona_name.replace("_", " ")]["movement"][1];
						movement_target[curr_persona_name] = [curr_x * tile_width, curr_y * tile_width];

						let action = all_movement[step][curr_persona_name.replace("_", " ")]["action"];

						let act = action;
						act = act.length > 25 ? act.substring(0, 20)+"..." : act;
						pronunciatios[curr_persona_name].setText(curr_persona_name + ": " + act);

						// Updating the status of each personas
						document.getElementById("agent_desc__"+curr_persona_name).innerHTML = all_movement["description"][curr_persona_name]["currently"];
						document.getElementById("current_action__"+curr_persona_name).innerHTML = action;
						document.getElementById("target_address__"+curr_persona_name).innerHTML = all_movement[step][curr_persona_name.replace("_", " ")]["location"];
					}

					if (execute_count > 0) {
						if (curr_persona.body.x < movement_target[curr_persona_name][0]) {
							curr_persona.body.x += movement_speed;
							anims_direction = "r";
							pre_anims_direction = "r";
							pre_anims_direction_dict[curr_persona_name] = "r";
						} else if (curr_persona.body.x > movement_target[curr_persona_name][0]) {
							curr_persona.body.x -= movement_speed;
							anims_direction = "l";
							pre_anims_direction = "l";
							pre_anims_direction_dict[curr_persona_name] = "l";
						} else if (curr_persona.body.y < movement_target[curr_persona_name][1]) {
							curr_persona.body.y += movement_speed;
							anims_direction = "d";
							pre_anims_direction = "d";
							pre_anims_direction_dict[curr_persona_name] = "d";
						} else if (curr_persona.body.y > movement_target[curr_persona_name][1]) {
							curr_persona.body.y -= movement_speed;
							anims_direction = "u";
							pre_anims_direction = "u";
							pre_anims_direction_dict[curr_persona_name] = "u";
						} else {
							anims_direction = "";
						}

						curr_pronunciatio.x = curr_persona.body.x - 15;
						curr_pronunciatio.y = curr_persona.body.y - 15 - 25;

						let left_walk_name = curr_persona_name + "-left-walk";
						let right_walk_name = curr_persona_name + "-right-walk";
						let down_walk_name = curr_persona_name + "-down-walk";
						let up_walk_name = curr_persona_name + "-up-walk";

						if (anims_direction == "l") {
							curr_persona.anims.play(left_walk_name, true);
						} else if (anims_direction == "r") {
							curr_persona.anims.play(right_walk_name, true);
						} else if (anims_direction == "u") {
							curr_persona.anims.play(up_walk_name, true);
						} else if (anims_direction == "d") {
							curr_persona.anims.play(down_walk_name, true);
						}
					}
				}
			} else {
				if (pre_anims_direction_dict[curr_persona_name] == "l") curr_persona.setTexture(curr_persona_name, "left");
				else if (pre_anims_direction_dict[curr_persona_name] == "r") curr_persona.setTexture(curr_persona_name, "right");
				else if (pre_anims_direction_dict[curr_persona_name] == "u") curr_persona.setTexture(curr_persona_name, "up");
				else if (pre_anims_direction_dict[curr_persona_name] == "d") curr_persona.setTexture(curr_persona_name, "down");
				curr_persona.anims.stop();

				finished = true;
				buttonPlay.text = "[回放结束]";
				buttonPause.setVisible(false);
			}
		}

		if (execute_count == 0) {
			for (let i = 0; i < Object.keys(personas).length; i++) {
				let curr_persona_name = Object.keys(personas)[i];
				let curr_persona = personas[curr_persona_name];
				curr_persona.body.x = movement_target[curr_persona_name][0];
				curr_persona.body.y = movement_target[curr_persona_name][1];
			}
			execute_count = execute_count_max + 1;
			step = step + 1;

			start_datetime = new Date(start_datetime.getTime() + step_size);
			// 同步更新右侧容器使用的时间
			start_datetime_temp = start_datetime;
			currentTime.setText(start_datetime.toLocaleTimeString("zh-CN", datetime_options));
			
			// Update agent logs if viewing
			if (show_agent_logs && selected_agent !== null) {
				updateAgentLogs(selected_agent);
			}
			
			// 实时更新右侧容器的日志（如果已选中角色）
			if (currentSelectedAgent && typeof rightContainer !== 'undefined' && typeof agent_logs_data !== 'undefined' && typeof updateRightContainerLogs === 'function') {
				updateRightContainerLogs(currentSelectedAgent, agent_logs_data, start_datetime);
			}
		}

		execute_count -= 1;
	}
</script>
